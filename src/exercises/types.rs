use bitcoin::bip32::Xpriv;
use bitcoin::script::ScriptBuf;
use bitcoin::secp256k1::{All, PublicKey, Secp256k1, SecretKey};
use bitcoin::Network;

// ============================================================================
// KEY FAMILY ENUM
// ============================================================================

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum KeyFamily {
    MultiSig = 0,
    RevocationBase = 1,
    HtlcBase = 2,
    PaymentBase = 3,
    DelayBase = 4,
    CommitmentSeed = 5,
    NodeKey = 6,
}

// ============================================================================
// KEY MANAGEMENT STRUCTURES
// ============================================================================

pub struct KeysManager {
    pub secp_ctx: Secp256k1<All>,
    pub master_key: Xpriv,
    pub network: Network,
}

/// Manages all cryptographic operations for a Lightning channel.
/// 
/// DESIGN NOTE: This structure combines key storage, derivation, and signing
/// into one unified manager for educational clarity. Production implementations
/// like LDK separate these concerns more strictly, but for learning purposes we
/// consolidate them to reduce cognitive load and show the relationships between
/// different key operations.
///
/// This structure handles:
/// - **Storage**: Holds all base keys and the commitment seed for a channel
/// - **Derivation**: Generates per-commitment points and derived keys (see keys/commitment.rs)
/// - **Signing**: Signs transaction inputs with the appropriate keys (see keys/sign.rs)
///
/// Historical note: Originally called InMemorySigner to match LDK naming, but renamed
/// to better reflect its combined responsibilities in this educational implementation.
pub struct ChannelKeyManager {
    pub funding_key: SecretKey,
    pub revocation_base_key: SecretKey,
    pub payment_base_key: SecretKey,
    pub delayed_payment_base_key: SecretKey,
    pub htlc_base_key: SecretKey,
    pub commitment_seed: [u8; 32],
    pub secp_ctx: Secp256k1<All>,
}

/// One counterparty's public keys which do not change over the life of a channel.
#[derive(Clone, Debug, Hash, PartialEq, Eq)]
pub struct ChannelPublicKeys {
    /// The public key which is used to sign all commitment transactions, as it appears in the
    /// on-chain channel lock-in 2-of-2 multisig output.
    pub funding_pubkey: PublicKey,
    /// The base point which is used (with [`RevocationKey::from_basepoint`]) to derive per-commitment
    /// revocation keys. This is combined with the per-commitment-secret generated by the
    /// counterparty to create a secret which the counterparty can reveal to revoke previous
    /// states.
    pub revocation_basepoint: PublicKey,
    /// The public key on which the non-broadcaster (ie the countersignatory) receives an immediately
    /// spendable primary channel balance on the broadcaster's commitment transaction. This key is
    /// static across every commitment transaction.
    pub payment_basepoint: PublicKey,
    /// The base point which is used (with derive_public_key) to derive a per-commitment payment
    /// public key which receives non-HTLC-encumbered funds which are only available for spending
    /// after some delay (or can be claimed via the revocation path).
    pub delayed_payment_basepoint: PublicKey,
    /// The base point which is used (with derive_public_key) to derive a per-commitment public key
    /// which is used to encumber HTLC-in-flight outputs.
    pub htlc_basepoint: PublicKey,
}

// ============================================================================
// OUTPUT SORTING STRUCTURES
// ============================================================================

#[derive(Debug, Clone)]
pub struct OutputWithMetadata {
    pub value: u64,
    pub script: ScriptBuf,
    pub cltv_expiry: Option<u32>,
}

#[derive(Debug, Clone)]
pub struct HTLCOutput {
    /// Amount in satoshis
    pub amount_sat: u64,
    /// Payment hash for this HTLC
    pub payment_hash: [u8; 32],
    /// CLTV expiry height
    pub cltv_expiry: u32,
}

// ============================================================================
// TEST VECTOR STRUCTURES
// ============================================================================

pub struct Bolt3TestVector {
    pub funding_txid: [u8; 32],
    pub funding_output_index: u32,
    pub funding_amount_satoshi: u64,
    pub funding_witness_script: Vec<u8>,
    pub commitment_number: u64,
    pub local_delay: u16,
    pub local_dust_limit_satoshi: u64,
    pub feerate_per_kw: u64,
    pub to_local_msat: u64,
    pub to_remote_msat: u64,
    pub local_funding_output_signature: Vec<u8>,
    pub remote_funding_output_signature: Vec<u8>,
    pub local_funding_privkey: SecretKey,
    pub remote_funding_pubkey: PublicKey,
    pub local_revocation_basepoint_secret: SecretKey,
    pub local_payment_basepoint_secret: SecretKey,
    pub local_delayed_payment_basepoint_secret: SecretKey,
    pub local_delayedpubkey: PublicKey,
    pub local_htlcpubkey: PublicKey,
    pub remote_htlcpubkey: PublicKey,
    pub local_htlc_basepoint_secret: SecretKey,
    pub local_htlc_basepoint: PublicKey,
    pub local_revocation_pubkey: PublicKey,
    pub remote_payment_basepoint: PublicKey,
    pub local_payment_basepoint: PublicKey,
    pub remote_delayed_payment_basepoint: PublicKey,
    pub remote_htlc_basepoint: PublicKey,
    pub commitment_seed: [u8; 32],
}

pub struct Bolt3Htlc {
    pub direction: HtlcDirection,
    pub amount_msat: u64,
    pub payment_hash: [u8; 32],
    pub cltv_expiry: u32,
}

pub enum HtlcDirection {
    Offered,
    Received,
}

// ============================================================================
// COMMITMENT KEYS STRUCTURE (Like LDK's TxCreationKeys)
// ============================================================================

/// The set of public keys which are used in the creation of one commitment transaction.
/// These are derived from the channel base keys and per-commitment point.
///
/// This structure is similar to LDK's TxCreationKeys and allows us to:
/// 1. Pre-derive all keys before building the transaction
/// 2. Pass exact keys from test vectors for testing
/// 3. Separate key derivation concerns from transaction building
#[derive(Clone, Debug)]
pub struct CommitmentKeys {
    /// The per-commitment point used to derive the other keys
    pub per_commitment_point: PublicKey,

    /// The revocation key which allows the broadcaster's counterparty to punish
    /// them if they broadcast an old state
    pub revocation_key: PublicKey,

    /// Local party's HTLC key (derived from local_htlc_basepoint)
    pub local_htlc_key: PublicKey,

    /// Remote party's HTLC key (derived from remote_htlc_basepoint)
    pub remote_htlc_key: PublicKey,

    /// Local party's delayed payment key (for to_local output)
    pub local_delayed_payment_key: PublicKey,
}
