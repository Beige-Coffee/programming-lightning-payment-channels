# Pulling It All Together: Build Our Commitment Transaction

We've come a long way! Let's piece together everything we've reviewed thus far and **fully** implement our first commitment transaction üòé.

Remember, we (Alice) will actually build **both** our version of the commitment transaction **and** Bob's version for each commitment state. Do you remember why we need to build Bob's version as well?

<details>
<summary>Answer</summary>

We need to build Bob's version so that we can generate a signature to send to Bob for *his* version of the commitment transaction!

</details>


<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/alice_refund_commit.png" alt="alice_refund_commit" width="60%" height="auto">
</p>

## Commitment Transaction Outputs
We'll start by focusing on commitment transaction outputs. Below are a few questions to build our intuition and see if you've been paying attention!

<details>
<summary>Do the outputs follow a specific order?</summary>

Yes! If you recall from earlier, the Lightning network spec (specifically, BOLT 3: [Transaction Output Ordering](https://github.com/lightning/bolts/blob/master/03-transactions.md#transaction-output-ordering)) specifies that outputs should be ordered in the following manner:
- First, according to their value - smallest first.
  - If there is a tie, the output with the lexicographically lesser `scriptpubkey` comes first, then selecting the shorter script (if they differ in length).
  - For HTLC outputs, if there is a tie after sorting via the above, then they are ordered in increasing `cltv_expiry` order.

</details>

<details>
<summary>Do Alice and Bob ALWAYS have an output - one for each of them?</summary>

No! We do not produce outputs for values that fall below the [dust limit](https://github.com/lightning/bolts/blob/master/03-transactions.md#dust-limits), as these would be uneconomical to spend on-chain anyway, and, therefore, just take up space and add extra fees to our commitment transaction.

To add further nuance, each party specifies its own dust limit, informing the peer of the thresholds below which it will not create outputs. These are communicated in the [open_channel](https://github.com/lightning/bolts/blob/master/02-peer-protocol.md#the-open_channel-message) and [channel_accept](https://github.com/lightning/bolts/blob/master/02-peer-protocol.md#the-open_channel-message) messages.

Channel party's balance is too small to have it's own output, it's added to fees and considered [**trimmed**](https://github.com/lightning/bolts/blob/master/03-transactions.md#trimmed-outputs).

</details>

<details>
<summary>Who pays the fees for this commitment transaction?</summary>

If you recall, we're following **Channel Establishment V1**, which is the simpler channel opening protocol where one party funds the channel and that same party pays the fees.

In our case, we (Alice) opened the channel, so we'll pay the fees - meaning that the fees will be subtracted from our channel balance.

</details>

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/alice_refund_outputs.png" alt="alice_refund_outputs" width="60%" height="auto">
</p>

### Commitment Transaction Fees

Now is as good a time as any to talk about fees! In bitcoin, there are two main contributors to fees:
- Transaction Weight: This is the size, in **virtual bytes** (vBytes), of a transaction.
- Demand for Blockspace: As you're likely aware, bitcoin blockspace is limited. Therefore, to get your transaction mined, you'll have to *incentivize* a miner to include your transaction in their block. Since many people are intersted in getting their transaction mined, a fee market comes comes into existance. To get your transaction mined, you'll have to pay for it!

#### Virtual Bytes (vBytes)
To understand a "virtual byte", let's first review a "byte". A **byte** is simply 8 bits of data. In the diagram below, you can see each field within a bitcoin transaction and its size (in bytes). If you'd like a more technical deep dive into the structure of a bitcoin transaction, check out Learn Me A Bitcoin's [Transaction resource](https://learnmeabitcoin.com/technical/transaction/).

The Segregated Witness (SegWit) upgrade introduced this idea of **weight**, which is the **size** (in bytes) of certain parts of the transaction by a **multiplier**. More specifically, non-witness data will be multiplied by 4, while witness data will be multiplied by 1. If you add up the resulting **size** x **multiplier**, you'll get the total weight of a transaction. Finally, if you divide the **weight** by 4, you get the **virtual bytes**. This is where the term "witness discount" comes from!

Therefore, the total fees that one would pay to get their transaction mined is measured by the number of satoshis they are willing to pay per virtual byte - also knowns as **sats/vByte**.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/fees.png" alt="fees" width="100%" height="auto">
</p>

#### Question: Assuming no HTLCs, does the weight of a Lightning Commitment transaction change?
<details>
<summary>Answer</summary>

I'll admit, this question may be a little unfair, since we have not yet reviewed HTLCs. However, since the diagram above answers this question pretty explicitly, maybe the question isn't unfair after all!

The answer is no! The weight for a commitment tranaction with no HTLCs is constant. This is because the variable-length fields (ex: `scriptPubKey`, `Witness`, etc.) are the same for each Lightning transaction. In other words, each Lightning transaction (without HTLCs or anchors) will only have a `to_local` and `to_remote` output. Additionally, the witness will always have two signatures and the standardized 2-of-2 multisig script.

Therefore, the **weight** of a simple (not HTLC or anchor) Lightning transaction is fixed at **724**. If you don't believe me or the diagram above, take a look at the [Fee Calculation](https://github.com/lightning/bolts/blob/master/03-transactions.md#fee-calculation) section of BOLT 3 (also shown below). Since we have no HTLCs, the weight is simply 724.

```
Commitment weight (no option_anchors):   724 + 172 * num-untrimmed-htlc-outputs
```

</details>

## ‚ö°Ô∏è Write A Function To Create Commitment Transaction Outptus

Alright, let's get to work! We'll start by completing `create_commitment_transaction_outputs`, which is located in `src/exercises/transactions/commitment.rs`. 

To complete this exercise, you'll need to return a `Vec` of `OutputWithMetadata` - a custom Rust Type which represents a commitment transaction output.

<details>
  <summary>Click to see the OutputWithMetadata Type</summary>

The OutputWithMetadata is a custom Type that represents a commitment transaction output. If you're familiar with Lightning and Hash Time-Locked Contracts (HTLCs), all of these fields may look familiar to you. If not, no worries at all! Below is a brief overview of what you'll need to know *for the purposes of this exercise*.
- `value`: This is simply the amount of bitcoin locked to this output.
- `script`: This is the script we're locking the bitcoin to. Since we've only learned about `to_local` and `to_remote` outputs thus far, you can imagine this holding the `ScriptBuf` type for those outputs.
- `cltv_expiry`: This .... is a surprise for later! If you know how HTLCs work, then this the expiry! It makes things easier and more intuitive if we include this in the OutputWithMetadata since we'll need to use it for sorting our outputs. Since we haven't covered HTLCs yet, we'll simply set this value to `None` for now.

```rust
pub struct OutputWithMetadata {
    pub value: u64,
    pub script: ScriptBuf,
    pub cltv_expiry: Option<u32>,
}
```
</details>

This function will take the following inputs:
- `to_local_value`: The amount of bitcoin being locked to the `to_local` script.
- `to_remote_value`: The amount of bitcoin being locked to the `to_remote` script.
- `commitment_keys`: This is a custom sruct that holds all of the keys you'll need to complete this transaction. You can learn more about it below.
- `remote_payment_basepoint`: This is the remote party's Payment Basepoint. You should know where this goes by now!
- `to_self_delay`: This is the number of blocks that the transaction holder needs to wait before they can claim their funds.
- `dust_limit_satoshis`: This is the dust limit, which is specific to each party. Remember, Alice and Bob specify their own dust limits when they open the channel to each other.
- `fee`: This is the fee that needs to be paid for this transaction. It's the sats/vByte, where vByte is our transaction's Weight Units / 4 (724).

 <details>
   <summary>Click to see the CommitmentKeys Type</summary>

The CommitmentKeys type is meant to hold all of the public keys we'll need for any given channel state. In other words, these keys have already been tweaked by the **Per Commitment Point** and are unique to a specific channel state.

 ```rust
pub struct CommitmentKeys {
    /// The per-commitment point used to derive the other keys
    pub per_commitment_point: PublicKey,

    /// The revocation key which allows the broadcaster's counterparty to punish
    /// them if they broadcast an old state
    pub revocation_key: PublicKey,

    /// Local party's HTLC key (derived from local_htlc_basepoint)
    pub local_htlc_key: PublicKey,

    /// Remote party's HTLC key (derived from remote_htlc_basepoint)
    pub remote_htlc_key: PublicKey,

    /// Local party's delayed payment key (for to_local output)
    pub local_delayed_payment_key: PublicKey,
}
 ```
 </details>

**PRO-TIP 1**: Since we're following **Channel Establishment V1** and we're acting as Alice, the fees should be deducted from our balance!

**PRO-TIP 2**: Remember, you should not add outputs if the channel party's balance is **below** the `dust_limit_satoshis`.

```rust
fn create_commitment_transaction_outputs(
    to_local_value: u64,
    to_remote_value: u64,
    commitment_keys: &CommitmentKeys,
    remote_payment_basepoint: &PublicKey,
    to_self_delay: u16,
    dust_limit_satoshis: u64,
    fee: u64,
) -> Vec<OutputWithMetadata> {
    let mut outputs = Vec::new();

    // Create to_remote output (goes to counterparty, immediately spendable)
    if to_remote_value >= dust_limit_satoshis {
        let to_remote_script = create_to_remote_script(remote_payment_basepoint);
        outputs.push(OutputWithMetadata {
            value: to_remote_value,
            script: to_remote_script,
            cltv_expiry: None,
        });
    }

    // Create to_local output (goes to us, revocable with delay)
    if to_local_value - fee >= dust_limit_satoshis {
        let to_local_script = create_to_local_script(
            &commitment_keys.revocation_key,
            &commitment_keys.local_delayed_payment_key,
            to_self_delay,
        );

        outputs.push(OutputWithMetadata {
            value: to_local_value - fee,
            script: to_local_script.to_p2wsh(),
            cltv_expiry: None,
        });
    }

    outputs
}
```

<details>
  <summary>Step 1: Initialize the Outputs Vector</summary>
    
First, we need to create a mutable vector to hold our commitment transaction outputs. 

```rust
let mut outputs = Vec::new();
```

We need it to be mutable (mut) because we'll be adding outputs to it as we go. Some outputs might be below the dust limit and won't be included at all.

</details>

<details>
  <summary>Step 2: Create the to_remote Output</summary>

The `to_remote` output pays the counterparty (the remote party). This output is immediately spendable by them with no delays or revocation conditions. However, we only create this output if the value meets or exceeds the dust limit.

```rust
if to_remote_value >= dust_limit_satoshis {
    let to_remote_script = create_to_remote_script(remote_payment_basepoint);
    outputs.push(OutputWithMetadata {
        value: to_remote_value,
        script: to_remote_script,
        cltv_expiry: None,
    });
}
```

</details>


<details>
  <summary>Step 3: Create the to_local Output</summary>

The `to_local` output pays us (the local party), but with important restrictions: it has a time delay and can be revoked by the counterparty if we try to broadcast an old state. The fee is deducted from our output since we're the one creating this commitment transaction.

```rust
if to_local_value - fee >= dust_limit_satoshis {
    let to_local_script = create_to_local_script(
        &commitment_keys.revocation_key,
        &commitment_keys.local_delayed_payment_key,
        to_self_delay,
    );
    outputs.push(OutputWithMetadata {
        value: to_local_value - fee,
        script: to_local_script.to_p2wsh(),
        cltv_expiry: None,
    });
}
```

</details>


<details>
  <summary>Step 4: Return the Outputs</summary>

  Finally, we return the vector containing all outputs that met the dust threshold. 

  ```rust
  outputs
  ```

  </details>


## ‚ö°Ô∏è Write A Function To Create An Unsigned Commitment Transaction

Let's continue our coding journey by implementing `create_commitment_transaction` in `src/exercises/transactions/commitment`. We'll use the function we created in the previous exercise (`create_commitment_transaction_outputs`) to build our outputs, add those to a `Transaction` struct, and then update the `timelock` and `sequence` fields with the obscured commitment number. Once we've completed this, we'll add the witness data, and we'll be good-to-go!

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/alice_refund_tx_no_sig.png" alt="alice_refund_tx_no_sig" width="100%" height="auto">
</p>


The `create_commitment_transaction` function takes the following inputs:

  ```rust
  pub fn create_commitment_transaction(
      funding_outpoint: OutPoint,
      to_local_value: u64,
      to_remote_value: u64,
      commitment_keys: &CommitmentKeys,
      local_payment_basepoint: &PublicKey,
      remote_payment_basepoint: &PublicKey,
      commitment_number: u64,
      to_self_delay: u16,
      feerate_per_kw: u64,
      offered_htlcs: Vec<(u64, [u8; 32])>,
      received_htlcs: Vec<(u64, [u8; 32], u32)>,
  ) -> Transaction {
      // Calculate fee based on number of HTLCs
      let num_htlcs = offered_htlcs.len() + received_htlcs.len();
      let fee = calculate_commitment_tx_fee(feerate_per_kw, num_htlcs);
      let mut output_metadata = Vec::new();

      let channel_outputs = create_commitment_transaction_outputs(
          to_local_value,
          to_remote_value,
          commitment_keys,
          remote_payment_basepoint,
          to_self_delay,
          fee,
      );

      let htlc_outputs = create_htlc_outputs(
          &commitment_keys,
          &offered_htlcs,
          &received_htlcs,
      );


      // Add to_local and to_remote outputs
      output_metadata.extend(channel_outputs);

      // Add all HTLC outputs
      output_metadata.extend(htlc_outputs);

      // Sort everything once
      sort_outputs(&mut output_metadata);

      // Convert to TxOut
      let outputs: Vec<TxOut> = output_metadata
          .iter()
          .map(|meta| TxOut {
              value: Amount::from_sat(meta.value),
              script_pubkey: meta.script.clone(),
          })
          .collect();

      let mut tx = Transaction {
          version: Version::TWO,
          lock_time: LockTime::ZERO,
          input: vec![TxIn {
              previous_output: funding_outpoint,
              script_sig: ScriptBuf::new(),
              sequence: Sequence::MAX,
              witness: Witness::new(),
          }],
          output: outputs,
      };

      set_obscured_commitment_number(
          &mut tx,
          commitment_number,
          local_payment_basepoint,
          remote_payment_basepoint
      );

      tx

  }
  ```