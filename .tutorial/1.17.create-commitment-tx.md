# Pulling It All Together: Build Our Commitment Transaction

We've come a long way! Let's piece together everything we've learned and **fully** implement our first commitment transaction, which we've been referring to as our "refund transaction" üòé.

Remember, Alice will actually build **both** her version of the commitment transaction **and** Bob's version for each commitment state. Do you remember why she needs to build Bob's version as well?

<details>
  <summary>Answer</summary>

We need to build Bob's version so that we can generate a signature to send to Bob for *his* version of the commitment transaction!

</details>

Take a look at the image below... we'll be translating this into code!

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/alice_refund_commit.png" alt="alice_refund_commit" width="60%" height="auto">
</p>

## Commitment Transaction Outputs

We'll start by focusing on commitment transaction outputs. Below are a few questions to build our intuition and see if you've been paying attention!

<details>
  <summary>Do the outputs follow a specific order?</summary>

Yes! If you recall from earlier, the Lightning network spec (specifically, BOLT 3: [Transaction Output Ordering](https://github.com/lightning/bolts/blob/master/03-transactions.md#transaction-output-ordering)) specifies that outputs should be ordered in the following manner:

- First, according to their value (smallest first).
  - If there is a tie, the output with the lexicographically lesser `scriptpubkey` comes first, then selecting the shorter script (if they differ in length).
  - For HTLC outputs, if there is a tie after sorting via the above, then they are ordered in increasing `cltv_expiry` order.

</details>

<details>
  <summary>Do Alice and Bob ALWAYS have an output? One for each of them?</summary>

No! We do not produce outputs for values that fall below the [dust limit](https://github.com/lightning/bolts/blob/master/03-transactions.md#dust-limits), as these would be uneconomical to spend on-chain, and therefore just take up space and add extra fees to our commitment transaction.

To add further nuance, each party specifies its own dust limit, informing the peer of the thresholds below which it will not create outputs. These are communicated in the [open_channel](https://github.com/lightning/bolts/blob/master/02-peer-protocol.md#the-open_channel-message) and [accept_channel](https://github.com/lightning/bolts/blob/master/02-peer-protocol.md#the-accept_channel-message) messages.

If a channel party's balance is too small to have its own output, it's added to fees and considered [**trimmed**](https://github.com/lightning/bolts/blob/master/03-transactions.md#trimmed-outputs).

</details>

<details>
  <summary>Who pays the fees for this commitment transaction?</summary>

If you recall, we're following **Channel Establishment V1**, which is the simpler channel opening protocol where one party funds the channel and that same party pays the fees.

In our case, Alice opened the channel, so she'll pay the fees - meaning that the fees will be subtracted from her channel balance.

</details>

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/alice_refund_outputs.png" alt="alice_refund_outputs" width="60%" height="auto">
</p>

## Commitment Transaction Fees

Now is as good a time as any to talk about fees! In Bitcoin, there are two main contributors to fees:

- **Transaction Weight**: This is the size, in **virtual bytes** (vBytes), of a transaction.
- **Demand for Blockspace**: As you're likely aware, Bitcoin blockspace is limited. Therefore, to get your transaction mined, you'll have to *incentivize* a miner to include your transaction in their block. Since many people are interested in getting their transaction mined, a fee market comes into existence. In other words, to get your transaction mined, you'll need to pay for it!

#### Virtual Bytes (vBytes)

To understand a "virtual byte", let's first review a "byte". A **byte** is simply 8 bits of data. In the diagram below, you can see each field within a Bitcoin transaction and its size (in bytes). By now, you should be familiar with most of these fields. However, there are a few that we haven't discussed, such as the Segwit Marker and Flag. Understanding these two fields is not imperative for this course, but if you'd like a more technical deep dive into the entire structure of a Bitcoin transaction, check out Learn Me A Bitcoin's [Transaction resource](https://learnmeabitcoin.com/technical/transaction/).

The Segregated Witness (SegWit) upgrade introduced the concept of **weight**, which is the **size** (in bytes) of certain parts of the transaction multiplied by a **multiplier**. For example, non-witness data is multiplied by 4, while witness data is multiplied by 1. If you add up the resulting **size √ó multiplier**, you get the **total weight** of a transaction. Finally, if you divide the **total weight** by 4, you get the **virtual bytes** of the transaction. This is where the term "witness discount" comes from - witness data has a lower multiplier (1x vs 4x), so it contributes proportionally less to fees than non-witness data.

The total fees that one would pay to get their transaction mined is measured by the **number of satoshis** they are willing to pay per **virtual byte**, also known as **sats/vByte**.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/fees.png" alt="fees" width="100%" height="auto">
</p>

#### Question: Assuming no HTLCs, does the weight of a Lightning commitment transaction change?

<details>
  <summary>Answer</summary>

I'll admit, this question may be a little unfair since we have not yet reviewed HTLCs. However, since the diagram above *mostly* answers this question pretty explicitly, maybe the question isn't unfair after all!

The answer is yes, it may change, but not by much! The weight for a commitment transaction with no HTLCs falls, roughly, within a pretty narrow range of 720-724. This is because the Lightning protocol defines how Lightning transactions are structured, so there is not much room for variation. In other words, each Lightning transaction (without HTLCs or anchors) will only have a `to_local` and `to_remote` output. Additionally, the witness will always have two signatures and the standardized 2-of-2 multisig script. That said, as you may be able to see from the diagram above, each signature (and sighash flag) will likely be 71, 72, or 73 bytes, so this will cause the total weight to vary slightly.

Therefore, the maximum **weight** (assuming 73-byte signatures) of a simple (no HTLC or anchor) Lightning commitment transaction is **724**. If you don't believe me or the diagram above, take a look at the [Fee Calculation](https://github.com/lightning/bolts/blob/master/03-transactions.md#fee-calculation) section of BOLT 3 (also shown below). Since we have no HTLCs, the weight is simply 724.

```
Commitment weight (no option_anchors):   724 + 172 * num-untrimmed-htlc-outputs
```

</details>

## ‚ö°Ô∏è Write A Function To Create Commitment Transaction Outputs

Alright, let's get to work! We'll start by completing `create_commitment_transaction_outputs`, which is located in `src/exercises/transactions/commitment.rs`.

To successfully complete this exercise, you'll need to return a `Vec` of `OutputWithMetadata`, a custom Rust type that represents a commitment transaction output. Make sure to check if the output values are below the dust limit before adding them! If both `to_local` and `to_remote` are above the dust limit, then your implementation should return a `Vec` of two `OutputWithMetadata` objects - one `to_local` and one `to_remote`.

<details>
  <summary>Click to see the OutputWithMetadata Type</summary>

`OutputWithMetadata` is a custom type that represents a commitment transaction output. To be clear, unlike many types we've reviewed thus far, this type is not provided by Rust Bitcoin - it's specific to the Programming Lightning course.

If you're familiar with Hash Time-Locked Contracts (HTLCs), all of these fields may look familiar. If not, no worries! Below is a brief overview of what you'll need to know ***for the purposes of this exercise***:

- `value`: The amount of bitcoin locked to this output.
- `script`: The script we're locking the bitcoin to. Since we've only learned about `to_local` and `to_remote` outputs thus far, you can imagine this holding the `ScriptBuf` type for those outputs.
- `cltv_expiry`: We'll cover this later when we discuss HTLCs! It's included in `OutputWithMetadata` because we'll need it for sorting outputs. Since there is no expiry for `to_local` and `to_remote` outputs, we'll set this to `None` for this exercise.
```rust
pub struct OutputWithMetadata {
    pub value: u64,
    pub script: ScriptBuf,
    pub cltv_expiry: Option<u32>,
}
```

</details>

This function takes the following inputs:

- `to_local_value`: The amount of bitcoin being locked to the `to_local` script.
- `to_remote_value`: The amount of bitcoin being locked to the `to_remote` script.
- `commitment_keys`: A custom struct that holds all of the keys you'll need to complete this transaction. See the dropdown below for more details.
- `remote_payment_basepoint`: The remote party's Payment Basepoint. You should know where this goes by now!
- `to_self_delay`: The number of blocks that the transaction holder needs to wait before they can claim their funds.
- `dust_limit_satoshis`: The dust limit. Remember, Alice and Bob specify their own dust limits when they open the channel.
- `fee`: The fee for this transaction.

<details>
  <summary>Click to see the CommitmentKeys Type</summary>

The `CommitmentKeys` type holds all of the public keys we need for any given channel state. In other words, these keys have already been tweaked by the **Per-Commitment Point** and are the public keys that we actually embed in the transaction scripts.
```rust
pub struct CommitmentKeys {
    /// The per-commitment point used to derive the other keys
    pub per_commitment_point: PublicKey,

    /// The revocation key which allows the broadcaster's counterparty to punish
    /// them if they broadcast an old state
    pub revocation_key: PublicKey,

    /// Local party's HTLC key (derived from local_htlc_basepoint)
    pub local_htlc_key: PublicKey,

    /// Remote party's HTLC key (derived from remote_htlc_basepoint)
    pub remote_htlc_key: PublicKey,

    /// Local party's delayed payment key (for to_local output)
    pub local_delayed_payment_key: PublicKey,
}
```

</details>

> üí° **TIP 1**: Since we're following **Channel Establishment V1** and we're acting as Alice, the fees should be deducted from our balance!

> üí° **TIP 2**: Remember, you should not add outputs if the channel party's balance is **below** the `dust_limit_satoshis`.
```rust
/// Exercise 18: Create commitment transaction outputs
pub fn create_commitment_transaction_outputs(
    to_local_value: u64,
    to_remote_value: u64,
    commitment_keys: &CommitmentKeys,
    remote_payment_basepoint: &PublicKey,
    to_self_delay: u16,
    dust_limit_satoshis: u64,
    fee: u64,
) -> Vec<OutputWithMetadata> {

    // Create a vector to store the outputs

    // Create to_remote output if above dust limit

    // Create to_local output if above dust limit (subtract fee from our balance)

    // Return the outputs

}
```

<details>
  <summary>üí° Hint üí°</summary>

This function creates the outputs for a commitment transaction. Below is a general approach with a few hints to help you complete the exercise.

1. **Create an empty `Vec` to hold the outputs.**

2. **Create the `to_remote` output:**
   - Remember to check if `to_remote_value >= dust_limit_satoshis`.
   - Use `create_to_remote_script()`, which we implemented earlier in this course. Make sure to pass in the correct public key!
   - Push an `OutputWithMetadata` with the value, script, and `cltv_expiry: None`.

3. **Create the `to_local` output:**
   - Once again, check if `to_local_value - fee >= dust_limit_satoshis`.
   - Use `create_to_local_script()`, which we implemented earlier in this course.
   - Remember, you'll need to convert the witness script (from `create_to_local_script()`) to a P2WSH using `.to_p2wsh()`.
   - Push an `OutputWithMetadata` with `value: to_local_value - fee`, the script, and `cltv_expiry: None`.

</details>

<details>
  <summary>Step 1: Initialize the Outputs Vector</summary>

Since we're returning a `Vec`, let's start by creating our `outputs` `Vec`. We'll need to ensure it's mutable so that we can make changes to its internal state later in the function.
```rust
let mut outputs = Vec::new();
```

</details>

<details>
  <summary>Step 2: Create the to_remote Output</summary>

Let's start with creating the `to_remote` output. That said, the order does not matter for this exercise, since we'll implement another function later to do the sorting.

To create the `to_remote` script, we can use the `create_to_remote_script` that we created earlier in this course. Since the remote output is always a simple P2WPKH output with the remote party's **Payment Basepoint**, we'll input their basepoint into the function. Remember to check if the `to_remote_value` is above the dust limit!

Next, we'll have to push the output to the `outputs` vector. However, we need to make sure we push the output as an `OutputWithMetadata` type with the appropriate fields.
```rust
if to_remote_value >= dust_limit_satoshis {
    let to_remote_script = create_to_remote_script(remote_payment_basepoint);
    outputs.push(OutputWithMetadata {
        value: to_remote_value,
        script: to_remote_script,
        cltv_expiry: None,
    });
}
```

</details>

<details>
  <summary>Step 3: Create the to_local Output</summary>

Now, let's add the `to_local` output. Once again, we'll check if it's above the dust limit first. If so, we'll use the `create_to_local_script` we created earlier. Once we have the script, we'll add the output as an `OutputWithMetadata` type with the appropriate fields.

For this output, we'll need to convert the witness script into a P2WSH script. We can do that using the `.to_p2wsh()` method, which is available on the witness script that is returned from `create_to_local_script`.
```rust
if to_local_value - fee >= dust_limit_satoshis {
    let to_local_script = create_to_local_script(
        &commitment_keys.revocation_key,
        &commitment_keys.local_delayed_payment_key,
        to_self_delay,
    );
    outputs.push(OutputWithMetadata {
        value: to_local_value - fee,
        script: to_local_script.to_p2wsh(),
        cltv_expiry: None,
    });
}
```

</details>

<details>
  <summary>Step 4: Return the Outputs</summary>

Finally, return the vector containing all outputs that met the dust threshold!
```rust
outputs
```

</details>


## ‚ö°Ô∏è Write A Function To Sort Outputs

Great, we're moving along! We now have a `Vec` of `OutputWithMetadata` types, where each instance represents a Bitcoin transaction output. Things are pretty simple now, as we only have two outputs, but like all things in life, things will get complicated eventually.

To prepare ourselves for the future, let's implement a function to sort a `Vec` of `OutputWithMetadata` types such that they follow the [Lightning Spec](https://github.com/lightning/bolts/blob/master/03-transactions.md#transaction-output-ordering). Fun fact: the Lightning specification actually follows [BIP 69](https://github.com/bitcoin/bips/blob/master/bip-0069.mediawiki), which recommends how various Bitcoin applications should order inputs and outputs in transactions. By standardizing this, we help improve privacy. Otherwise, if individual applications all had their own logic for sorting inputs/outputs, they would leave a public "fingerprint" on the blockchain and it would be much easier to determine which software created which transaction.

Lightning builds on BIP 69 by adding a CLTV Expiry sort after first sorting by value and then lexicographically.

To successfully complete this exercise, implement `sort_outputs`, which takes a mutable reference to a `Vec` of `OutputWithMetadata` types. You may notice this function does not return anything! That's because the function updates the `Vec` in-place, changing its internal state.

You can click below to remind yourself of which fields are available within `OutputWithMetadata`. You must sort the outputs as follows:

- First, according to their value (smallest first).
  - If there is a tie, the output with the lexicographically lesser `scriptpubkey` comes first, then selecting the shorter script (if they differ in length).
  - For HTLC outputs, if there is a tie after sorting via the above, they are ordered in increasing `cltv_expiry` order.

<details>
  <summary>Click to see the OutputWithMetadata Type</summary>
    
```rust
pub struct OutputWithMetadata {
    pub value: u64,
    pub script: ScriptBuf,
    pub cltv_expiry: Option<u32>,
}

```

</details>

```rust
/// Exercise 19: Sort outputs according to BOLT 3
pub fn sort_outputs(outputs: &mut Vec<OutputWithMetadata>) {
    
    // Sort by value, then script, then CLTV expiry (BIP69-style)

}
```

<details>
  <summary>üí° Hint üí°</summary>

This exercise should be a little simpler than some of the previous ones (especially the one where we did all that bit shifting!).

To complete this exercise, you need to sort the `outputs` `Vec`. You can use Rust's `sort_by` method, which lets you define custom sorting logic. Here's the general structure:

```rust
outputs.sort_by(|a, b| {
    a.value.cmp(/* primary sort */)
        .then(/* secondary sort */)
        .then(/* tertiary sort */)
});
```

The `sort_by` closure compares two elements (`a` and `b`) at a time to determine their order. The `.cmp()` method returns whether `a` is less than, equal to, or greater than `b`. If the two values are equal, `.then()` kicks in and evaluates the next comparison. This lets us chain multiple sort criteria together.

Compare these fields in the following order to pass the exercise:

1. **Value** (ascending, smallest first)
2. **Script** (lexicographically)
3. **CLTV Expiry** (ascending, for HTLC outputs)

</details>

<details>
  <summary>Step 1: Use sort_by for Multi-Level Sorting</summary>

For this exercise, we'll use Rust's `sort_by` method, which allows us to define custom sorting logic.

The `sort_by` method takes a closure that compares two elements (`a` and `b`) and returns an `Ordering`. The function mutates the vector in place, which is why `outputs` is a mutable reference (`&mut`) and the function does not return anything.

```rust
pub fn sort_outputs(outputs: &mut Vec<OutputWithMetadata>) {
    
  outputs.sort_by(|a, b| {
      a.value.cmp(/* primary sort */)
          .then(/* secondary sort */)
          .then(/* tertiary sort */)
  });

}
```

</details>

<details>
  <summary>Step 2: Sort by Value First</summary>

Per BOLT 3, we need to first sort by output value. Lower amounts should come first.

Since `value` is a `u64`, which implements Rust's `Ord` trait (the standard trait for types that can be ordered), we can use the `.cmp()` method to compare two values. It returns:

- `Ordering::Less` if `a.value < b.value`
- `Ordering::Equal` if `a.value == b.value`
- `Ordering::Greater` if `a.value > b.value`
- 
```rust
a.value.cmp(&b.value)
```

</details>

<details>
  <summary>Step 3: Add Script as Secondary Sort</summary>

If two outputs have the same value, we need a tiebreaker, so we'll sort lexicographically by the script bytes using the `then` combinator.

Since `ScriptBuf` also implements `Ord`, we can use `.cmp()` directly on the script. The comparison is done byte-by-byte in lexicographic order.

```rust
a.value
    .cmp(&b.value)
    .then(a.script.cmp(&b.script))
```

</details>

<details>
  <summary>Step 4: Add CLTV Expiry as Final Tiebreaker</summary>

Finally, in rare cases, two HTLC outputs might have the same value AND the same script (they use the same payment hash and keys). In these scenarios, we'll use the CLTV expiry as a final tiebreaker.

```rust
a.value
    .cmp(&b.value)
    .then(a.script.cmp(&b.script))
    .then(a.cltv_expiry.cmp(&b.cltv_expiry))
```

</details>



## ‚ö°Ô∏è Write A Function To Create An Unsigned Commitment Transaction

Let's continue our coding journey by implementing `create_commitment_transaction` in `src/exercises/transactions/commitment.rs`. We'll use the function we created in the previous exercise (`create_commitment_transaction_outputs`) to build our outputs, add those to a `Transaction` struct, and then update the `lock_time` and `sequence` fields with the obscured commitment number.

In the next exercise, we'll add the witness data, and then we'll be good to go!

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/alice_refund_tx_no_sig.png" alt="alice_refund_tx_no_sig" width="60%" height="auto">
</p>

The `create_commitment_transaction` function takes the following inputs:

- `funding_outpoint`: The outpoint of the Funding Transaction (the 2-of-2 multisig output we're spending).
- `to_local_value`: The amount of bitcoin for the `to_local` output.
- `to_remote_value`: The amount of bitcoin for the `to_remote` output.
- `commitment_keys`: The derived keys for this commitment state.
- `local_payment_basepoint`: Our Payment Basepoint.
- `remote_payment_basepoint`: The remote party's Payment Basepoint.
- `commitment_number`: The commitment number for this state.
- `to_self_delay`: The number of blocks we must wait before claiming our funds.
- `dust_limit_satoshis`: The dust limit threshold.
- `feerate_per_kw`: The fee rate in satoshis per 1000 weight units.
- `offered_htlcs`: HTLCs we're offering (we'll cover these later!).
- `received_htlcs`: HTLCs we've received (we'll cover these later!).

> üí° **Note**: Don't worry about the `offered_htlcs` and `received_htlcs` parameters for now. We'll dive into those in a later section. For this exercise, these will be empty arrays.

```rust
/// Exercise 20 (& 29): Create complete commitment transaction
pub fn create_commitment_transaction(
    funding_outpoint: OutPoint,
    to_local_value: u64,
    to_remote_value: u64,
    commitment_keys: &CommitmentKeys,
    local_payment_basepoint: &PublicKey,
    remote_payment_basepoint: &PublicKey,
    commitment_number: u64,
    to_self_delay: u16,
    dust_limit_satoshis: u64,
    feerate_per_kw: u64,
    offered_htlcs: &[HTLCOutput],
    received_htlcs: &[HTLCOutput],
) -> Transaction {
    // Calculate commitment transaction fee
    let num_htlcs = offered_htlcs.len() + received_htlcs.len();
    let fee = calculate_commitment_tx_fee(feerate_per_kw, num_htlcs);

    // Create to_local and to_remote outputs

    // Sort outputs per BOLT 3

    // Convert to TxOut format

    // Build transaction spending from funding output

    // Set obscured commitment number in locktime and sequence

    // Return transaction
}
```

<details>
  <summary>üí° Hint üí°</summary>

This function brings together several pieces we've worked on during this course. Here's the general approach:

1. **Calculate the fee**
   - First, we'll need to calculate the fee for this transaction. This code has already been provided for you, so no need to worry about this!

2. **Create the outputs**
   - Use `create_commitment_transaction_outputs()` to create the `Vec` of our commitment transaction's outputs.

3. **Sort the outputs**
   - Once you have the outputs, sort them using the `sort_outputs` function we implemented previously.

4. **Convert `OutputWithMetadata` to `TxOut`**
   - Since the `Transaction` struct expects `TxOut` types (not our custom `OutputWithMetadata`), you'll need to map each `OutputWithMetadata` to a `TxOut`. Below is some helper code you can use:
```rust
   let outputs: Vec<TxOut> = channel_outputs
       .iter()
       .map(|meta| TxOut {
           value: Amount::from_sat(meta.value),
           script_pubkey: meta.script.clone(),
       })
       .collect();
```

5. **Build the `Transaction` struct** with:
   - `version: Version::TWO`
   - `lock_time: LockTime::ZERO` (we'll update this next)
   - A single input spending the `funding_outpoint`
   - The sorted outputs

6. **Set the obscured commitment number**
   - Use `set_obscured_commitment_number()` to update the `lock_time` and `sequence` fields.

7. **Return the transaction!**

</details>

<details>
  <summary>Step 1: Calculate the Transaction Fee</summary>

First, we'll need to figure out how much the commitment transaction will cost in fees. As we learned earlier, this depends on the size of the transaction and the current demand for blockspace. Lucky for you, the fee calculation has already been provided, so you don't need to worry about this for the exercise.
```rust
let num_htlcs = offered_htlcs.len() + received_htlcs.len();
let fee = calculate_commitment_tx_fee(feerate_per_kw, num_htlcs);
```

</details>

<details>
  <summary>Step 2: Create the Channel Balance Outputs</summary>

Next, let's create the main outputs that represent each party's balance in the channel. These are the `to_local` and `to_remote` outputs. We'll use the `create_commitment_transaction_outputs` function that we implemented in an earlier exercise.
```rust
let mut channel_outputs = create_commitment_transaction_outputs(
    to_local_value,
    to_remote_value,
    commitment_keys,
    remote_payment_basepoint,
    to_self_delay,
    dust_limit_satoshis,
    fee,
);
```

</details>

<details>
  <summary>Step 3: Sort the Outputs</summary>

Now that we have our commitment transaction outputs, let's sort them according to the BOLT 3 specification.
```rust
sort_outputs(&mut channel_outputs);
```

</details>

<details>
  <summary>Step 4: Convert to Transaction Outputs</summary>

Ultimately, we need to build a `Transaction` object. Since the `Transaction` struct expects `TxOut` types (not our custom `OutputWithMetadata`), we need to map each `OutputWithMetadata` to a `TxOut`.
```rust
let outputs: Vec<TxOut> = channel_outputs
    .iter()
    .map(|meta| TxOut {
        value: Amount::from_sat(meta.value),
        script_pubkey: meta.script.clone(),
    })
    .collect();
```

</details>

<details>
  <summary>Step 5: Create the Transaction</summary>

Let's assemble all the pieces into a `Transaction`. We'll make this transaction `mut` (mutable) because we'll need to modify it in the next step.
```rust
let mut tx = Transaction {
    version: Version::TWO,
    lock_time: LockTime::ZERO,
    input: vec![TxIn {
        previous_output: funding_outpoint,
        script_sig: ScriptBuf::new(),
        sequence: Sequence::MAX,
        witness: Witness::new(),
    }],
    output: outputs,
};
```

</details>

<details>
  <summary>Step 6: Set the Obscured Commitment Number</summary>

Finally, we need to encode the commitment number into the transaction using the `set_obscured_commitment_number` function we created earlier.
```rust
set_obscured_commitment_number(
    &mut tx,
    commitment_number,
    local_payment_basepoint,
    remote_payment_basepoint,
);

tx
```

</details>

## Signing A Commitment Transaction

Let's finish this up by signing our commitment transaction and adding both our signature and Bob's signature to the witness. Remember, as part of **Channel Establishment V1**, Bob will send Alice **his** signature for **Alice's** version of the first commitment transaction, and Alice will send Bob **her** signature for **his** version of the commitment transaction.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/alice_bob_channel_establishment.png" alt="alice_bob_channel_establishment" width="100%" height="auto">
</p>

If Alice wanted to broadcast her version of the first commitment transaction, she could simply generate her own signature and add it, along with Bob's signature and the witness script, to the witness. This would satisfy the spending conditions and allow her to broadcast her version of the commitment transaction.

#### Question: When Alice receives Bob's signature, will she sign her version of the commitment transaction and save the fully signed transaction somewhere? Or will she wait to sign it?

<details>
  <summary>Answer</summary>

Lightning implementations will ***not*** fully sign their version of the commitment transactions **until** they intend to broadcast them. If they did fully sign them and stored them in memory or a database, this would put them at risk of being published early - either by accident or by a malicious actor that gains access to them.

Therefore, it's best practice to wait to sign your version of a commitment transaction until you intend to publish it.

</details>

## ‚ö°Ô∏è Write A Function To Sign A Commitment Transaction

For this exercise, we'll implement `finalize_holder_commitment`. This function will take a transaction, produce a signature using the **Funding Private Key**, and add the appropriate witness data to satisfy the 2-of-2 multisig spending condition. It will return the resulting transaction, ready to be broadcast.

To successfully complete this exercise, you'll want to make use of the `ChannelKeyManager`, which we created earlier in this course. Specifically, you'll use the `ChannelKeyManager` to:

1. Obtain the **Funding Private Key**.
2. Sign the 2-of-2 multisig funding input with `sign_transaction_input_sighash_all`, which we completed in an earlier exercise.

<details>
  <summary>Click here to see the sign_transaction_input_sighash_all function definition</summary>
    
```rust
pub fn sign_transaction_input_sighash_all(
    &self,
    tx: &Transaction,
    input_index: usize,
    script: &ScriptBuf,
    amount: u64,
    secret_key: &SecretKey,
) -> Vec<u8> {

```

</details>

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/alice_refund_tx_yes_sig.png" alt="alice_refund_tx_yes_sig" width="60%" height="auto">
</p>

This function takes the following inputs:

- `keys_manager`: Our `ChannelKeyManager`, which contains the channel private keys and signing functionality.
- `tx`: The current, unsigned, commitment transaction.
- `input_index`: The index of the 2-of-2 multisig input we're signing.
- `funding_script`: The 2-of-2 multisig witness script.
- `funding_amount`: The amount of funds locked in the 2-of-2 multisig.
- `remote_funding_signature`: Our remote counterparty's signature to spend from the 2-of-2 multisig input.
- `local_sig_first`: A boolean value, indicating if our local signature should come before the remote signature in the witness.

Go ahead and give it a try!

```rust
/// Exercise 21: Finalize holder commitment transaction
pub fn finalize_holder_commitment(
    keys_manager: ChannelKeyManager,
    tx: Transaction,
    input_index: usize,
    funding_script: &ScriptBuf,
    funding_amount: u64,
    remote_funding_signature: Vec<u8>,
    local_sig_first: bool,
) -> Transaction {

    // Get the local funding private key

    // Sign the transaction input with the local funding private key

    // Build witness stack with signatures in correct order (include OP_0 for CHECKMULTISIG bug)

    // Attach witness to transaction

    // Return Transaction

}
```


<details>
  <summary>üí° Hint üí°</summary>

To complete this function, you'll need to generate a signature using the **Funding Private Key**, and then add your signature along with your counterparty's signature, funding witness script, and a dummy value to the witness. Once complete, the witness will have the below structure:
```
0, signature_1, signature_2, witness_script
```

> ‚ùó **NOTE**: The order of the signatures depends on the order of the public keys in the 2-of-2 funding script! You can use the `local_sig_first` parameter to determine which order you should push the signatures to the stack. For example, if `local_sig_first` is `true`, then the local signature comes first; otherwise, the remote signature comes first.

Below are some helpful hints to guide you through this exercise.

1. **Get the Funding Private Key**
   - If you remember, once upon a time, we created `keys_manager` as part of an earlier exercise. You can access the Funding Private Key from the `keys_manager` using `keys_manager.funding_key`.

2. **Generate our signature**
   - Next, we'll sign the transaction using `keys_manager.sign_transaction_input_sighash_all()`. Make sure to use the Funding Private Key!

3. **Build the witness stack**
   - For a 2-of-2 multisig P2WSH input, you will need to add the following elements to the witness (in the below order):
     - An empty byte array (for the `OP_CHECKMULTISIG` off-by-one bug)
     - Signature 1 (depends on `local_sig_first`)
     - Signature 2 (depends on `local_sig_first`)
     - The witness script (the 2-of-2 multisig script)
   - You can use `Witness::from_slice()` to build the witness.

4. **Attach the witness to the transaction**
   - You can input the witness into the transaction using `signed_tx.input[0].witness = witness`.

5. **Return the signed transaction!**

</details>

<details>
  <summary>Step 1: Get the Local Funding Private Key</summary>

First, we need to retrieve our **Funding Private Key** from the `keys_manager`, which we implemented much earlier in the course. As a reminder, this is the key that corresponds to our **Funding Public Key** in the 2-of-2 multisig, and we'll need it to sign the input for our new commitment transaction.
```rust
let local_funding_privkey = keys_manager.funding_key;
```

</details>

<details>
  <summary>Step 2: Sign the Transaction Input</summary>

Next, let's plug everything into the signing function we created earlier.
```rust
let local_funding_signature = keys_manager.sign_transaction_input_sighash_all(
    &tx,
    input_index,
    &funding_script,
    funding_amount,
    &local_funding_privkey,
);
```

</details>

<details>
  <summary>Step 3: Build the Witness Stack</summary>

If you recall from earlier in the course, the **Funding Public Keys** are sorted lexicographically when placed into the 2-of-2 multisig script. Therefore, we'll need to sort the signatures such that they correspond to the right public key. Otherwise, the signatures will be considered invalid (because they will be evaluated against the incorrect public key), and we won't be able to broadcast our commitment transaction!

Lucky for us, the `local_sig_first` parameter tells us whether our public key comes before the remote public key in the funding script. So, we'll use this to determine which signature to place first.
```rust
let witness = if local_sig_first {
    Witness::from_slice(&[
        &[][..],                        // OP_0 for CHECKMULTISIG bug
        &local_funding_signature[..],   // Our signature first
        &remote_funding_signature[..],  // Remote signature second
        funding_script.as_bytes(),      // The witness script
    ])
} else {
    Witness::from_slice(&[
        &[][..],                        // OP_0 for CHECKMULTISIG bug
        &remote_funding_signature[..],  // Remote signature first
        &local_funding_signature[..],   // Our signature second
        funding_script.as_bytes(),      // The witness script
    ])
};
```

</details>

<details>
  <summary>Step 4: Attach the Witness to the Transaction</summary>

Now that our witness is defined, let's attach it to the appropriate input in the transaction. Since we only have one input, this will be easy - it's index 0.
```rust
let mut signed_tx = tx;
signed_tx.input[0].witness = witness;

signed_tx
```

</details>